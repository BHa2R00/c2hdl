(require "asdf")
(require "cl-ppcre")
(defun pscan (e s) (cl-ppcre:scan-to-strings e s))
(defun pmatch (e s) (cl-ppcre:all-matches-as-strings e s))
(defun preplace (e1 s e2) (cl-ppcre:regex-replace-all e1 s e2))
(defun psplit (e s) (cl-ppcre:split e s))
(defun pquote (b) (cl-ppcre:quote-meta-chars b))

(defparameter *asm* (list))
(defparameter *cpu* nil)
(defparameter *reg* (list))
(defparameter *reg0* (list))
(defparameter *rstb* "rstb")
(defparameter *clk* "clk")
(defparameter *pc* "pc")
(defparameter *pcmax* nil)
(defparameter *pcmin* nil)
(defparameter *pcmsb* 0)
(defparameter *setb* "setb")
(defparameter *idle* "idle")
(defparameter *pc0* "pc0")
(defparameter *addr* "addr")
(defparameter *wdata* "wdata")
(defparameter *size* "size")
(defparameter *rdata* "rdata")
(defparameter *valid* "valid")
(defparameter *ready* "ready")
(defparameter *write* "write")
(defparameter *log* (list))
(defparameter *hdl* nil)
(defparameter *debug* nil)
(defparameter *module* nil)
(defparameter *msb* 31)
(defun read-asm (s)
  (do ((line (read-line s nil :eof)
             (read-line s nil :eof)))
    ((equalp line :eof))
    (setf line (preplace "[;]{1}(.*)" line ""))
    (if (or
          (pscan "^\\s+[0-9a-f]+:\\s+" line)
          (pscan "^[0-9a-f]+\\s+\\S+:" line)
          )
      (let ()
        ;(setf line (preplace "\\b([0-9a-f]{2,}:)\\b" line "#x\\1"))
        ;(format t "~S~%" line)
        (if (> (length line) 24)
          (let ((line1 (subseq line 0 24))
                (line2 (subseq line 24)))
            (setf line1 (string-trim '(#\Space) line1))
            (setf line1 (preplace ":" line1 " "))
            (setf line1 (psplit "\\s+" line1))
            (setf line1 (concatenate 'string "0x" (car line1)))
            (setf line (concatenate 'string line1":          	" line2))
            ))
        ;(setf line (preplace "\\s+b\\s+" line " j "))
        (setf line (preplace "[:]{1}\\s*" line " = "))
        (setf line (substitute #\Space #\, line))
        (setf line (preplace "[-]{1}0x" line "0x-"))
        (setf line (preplace "[\\$]{1}0x" line "$ 0x"))
        (setf line (preplace "0x" line "#x"))
        (setf line (preplace "[(]{1}" line " ("))
        (setf line (preplace "fp" line "s0"))
        (setf line (preplace "ruipc" line "auipc"))
        (setf line (string-trim '(#\space) line))
        (setf line (psplit "\\s+" line))
        ;(format t "~S~%" line)
        (setf 
          line
          (map 'list
               (lambda (e)
                 (cond
                   ((pscan "^#x" e) (read-from-string e))
                   ((pscan "^[0-9]+$" e) (read-from-string e))
                   (t e)))
               line))
        ))
    (setf *asm* (append *asm* (list line)))
    )
  ;(format t "~S~%" *asm*)
  )
(defun cpu (f)
  (cond
    ((member *cpu* '("rv32e" "rv32em" "rv32i" "rv32im") :test #'equalp) (setf *msb* 31))
    ((member *cpu* '("rv64i") :test #'equalp) (setf *msb* 63))
    )
  (cond
    ((member *cpu* '("rv32e" "rv32em" "rv32i" "rv32im" "mips") :test #'equalp)
     (let ()
       (setf *reg* (list))
       (cond
         ((member *cpu* '("rv32i" "rv32im" "rv46i") :test #'equalp)
          (let ()
             (setf *reg* (append *reg* (psplit "\\s+" "ra sp gp tp")))
             (setf *reg* (append *reg* (psplit "\\s+" "t0 t1 t2 t3 t4 t5 t6")))
             (setf *reg* (append *reg* (psplit "\\s+" "s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11")))
             (setf *reg* (append *reg* (psplit "\\s+" "a0 a1 a2 a3 a4 a5 a6 a7")))
            ))
         ((member *cpu* '("rv32e" "rv32em") :test #'equalp)
          (let ()
             (setf *reg* (append *reg* (psplit "\\s+" "ra sp gp tp")))
             (setf *reg* (append *reg* (psplit "\\s+" "t0 t1 t2")))
             (setf *reg* (append *reg* (psplit "\\s+" "s0 s1")))
             (setf *reg* (append *reg* (psplit "\\s+" "a0 a1 a2 a3 a4 a5")))
            ))
         (t
           (let ()
             (setf *reg* (append *reg* (psplit "\\s+" "ra sp gp fp")))
             (setf *reg* (append *reg* (psplit "\\s+" "t0 t1 t2 t3 t4 t5 t6 t7 t8 t9")))
             (setf *reg* (append *reg* (psplit "\\s+" "s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11")))
             (setf *reg* (append *reg* (psplit "\\s+" "v0 v1")))
             (setf *reg* (append *reg* (psplit "\\s+" "k0 k1")))
             (setf *reg* (append *reg* (psplit "\\s+" "a0 a1 a2 a3 a4 a5 a6 a7")))
             (setf *reg* (append *reg* (psplit "\\s+" "LO HI")))
             )))
       (format t "remove unused registers~%")
       (let ((reg (list))
             (pclist (list)))
         (map 'list
              (lambda (line)
                (map 'list
                     (lambda (r)
                       (if (and
                             (listp line)
                             (or
                               (member r line :test #'equalp)
                               (member (concatenate 'string "("r")") line :test #'equalp)))
                         (push r reg)))
                     *reg*)
                (if (and 
                      (listp line)
                      (nth 1 line)
                      (equalp (nth 1 line) "=")
                      (numberp (car line)))
                  (push (car line) pclist))
                )
              *asm*)
         (setf reg (remove-duplicates reg :test #'equalp))
         (format t "~S~%" reg)
         (setf *reg* reg)
         (setf *pcmax* (apply #'max pclist))
         (setf *pcmin* (apply #'min pclist))
         (setf *pcmsb* 0)
         (do ((a (ash 1 *pcmsb*) (ash 1 *pcmsb*)))
           ((>= a (+ 4 *pcmax*)) (decf *pcmsb*))
           (incf *pcmsb*))
         (format t "pc msb = ~A ~%" *pcmsb*)
         )
       (setf *reg0* (map 'list (lambda (r) (concatenate 'string r"0")) *reg*))
       (if *module*
         (let ()
           (format f "module ~A (~{~A~^, ~});~%" *module* (append (list *clk* *rstb* *setb* *idle* *pc* *pc0* *addr* *size* *valid* *write* *wdata* *rdata* *ready*) *reg0*))
           (format f "input ~{~A~^, ~};~%" (list *clk* *rstb*))
           (format f "input ~{~A~^, ~};~%" (list *setb*))
           (format f "output reg ~{~A~^, ~};~%" (list *idle*))
           (format f "output reg [~A:0] ~{~A~^, ~};~%" *pcmsb* (list *pc*))
           (format f "input [~A:0] ~{~A~^, ~};~%" *pcmsb* (list *pc0*))
           (format f "output reg [~A:0] ~{~A~^, ~};~%" *msb* (list *addr*))
           (format f "output reg [2:0] ~{~A~^, ~};~%" (list *size*))
           (format f "output reg ~{~A~^, ~};~%" (list *valid* *write*))
           (format f "output reg [~A:0] ~{~A~^, ~};~%" *msb* (list *wdata*))
           (format f "input [~A:0] ~{~A~^, ~};~%" *msb* (list *rdata*))
           (format f "input ~{~A~^, ~};~%" (list *ready*))
           (format f "input [~A:0] ~{~A~^, ~};~%" *msb* *reg0*)
           ))
       ;(format f "wire [31:0] ~A_w = ~A >> (8*~A[1:0]);~%" *rdata* *rdata* *addr*)
       ;(format f "wire [15:0] ~A_h = ~A >> (8*~A[1:0]);~%" *rdata* *rdata* *addr*)
       ;(format f "wire [ 7:0] ~A_b = ~A >> (8*~A[1:0]);~%" *rdata* *rdata* *addr*)
       (format f "wire [31:0] ~A_w = ~A;~%" *rdata* *rdata*)
       (format f "wire [15:0] ~A_h = ~A;~%" *rdata* *rdata*)
       (format f "wire [ 7:0] ~A_b = ~A;~%" *rdata* *rdata*)
       (format f "reg [~A:0] zero, ~{~A~^, ~};~%" *msb* *reg*)
       (format f "always@(negedge ~A or posedge ~A) begin~%" *rstb* *clk*)
       (format f "  if(!rstb) begin~%")
       (format f "    zero <= 32'd0;~%")
       (format f "    ~A <= 1;~%" *idle*)
       (format f "    ~A <= 0;~%" *valid*)
       (format f "    ~A <= 0;~%" *write*)
       (format f "    ~A <= 0;~%" *size*)
       (format f "    ~A <= 0;~%" *addr*)
       (format f "  end~%")
       (format f "  else begin~%")
       (format f "    zero <= 32'd0;~%")
       ;(format f "    ~A <= 0;~%" *valid*)
       ;(format f "    ~A <= 0;~%" *write*)
       ;(format f "    ~A <= 0;~%" *size*)
       (format f "    if(!~A) begin~%" *setb*)
       (format f "      ~A <= (~A > 'h~x) ? 'h~x + 4 : ~A;~%" *pc* *pc0* *pcmax* *pcmax* *pc0*)
       (map 'list
            (lambda (r r0)
              (format f "      ~A <= ~A;~%" r r0)
              )
            *reg*
            *reg0*
            )
       (format f "      ~A <= 0;~%" *idle*)
       (format f "    end~%")
       (format f "    else if(!~A) begin~%" *idle*)
       (format f "      ~A <= (~A > 'h~x) ? 'h~x + 4 : ~A + 4;~%" *pc* *pc* *pcmax* *pcmax* *pc*)
       ;(format f "      if(~A >= ~A) ~A <= 1;~%" *pc* *pc1* *idle*)
       ;(format f "      if(&~A) ~A <= 1;~%" *pc* *idle*)
       (format f "      if(~A == ra0) ~A <= 1;~%" *pc* *idle*)
       (format f "      case(~A)~%" *pc*)
       (dotimes (k (length *asm*))
         (let ((line (nth k *asm*))
               (op '(
                     ("add"   "+") ("addi"   "+")
                     ("addu"  "+") ("addiu"  "+")
                     ("and"   "&") ("andi"   "&")
                     ("nand" "~&") ("nandi" "~&")
                     ("or"    "&") ("ori"    "&")
                     ("nor"  "~|") ("nori"  "~|")
                     ("xor"   "^") ("xori"   "^")
                     ("sll"  "<<") ("slli"  "<<")
                     ("sllv" "<<") ("sllvi" "<<")
                     ("srl"  ">>") ("srli"  ">>")
                     ("srlv" ">>") ("srlvi" ">>")
                     ("sub"   "-") ("subi"   "-")
                     ("subu"  "-") ("subiu"  "-")
                     ("mul"   "*") ("muli"   "*")
                     ("div"   "/") ("divi"   "/")
                     ))
               (op1 '(
                     ("not"  "~") ("neg"  "0-") ("negu"  "0-")
                     ))
               (op2 '(
                     ("zext.b" "32'hff") 
                     ("zext.h" "32'hffff") 
                     ))
               (br1 '(
                     ("beqz" " == 0") ("bnez" " != 0")
                     ("bltz" "  < 0") ("bgez" " >= 0")
                     ("blez" " <= 0") ("bgtz" " >  0")
                     ))
               (br2 '(
                     ("beq"  "==") ("bne"  "!=")
                     ("blt"  "<" ) ("bge"  ">=")
                     ("ble"  "<=") ("bgt"  ">" )
                     ))
               (br3 '(
                     ("bltu" "<" ) ("bgeu" ">=")
                     ("bleu" "<=") ("bgtu" ">" )
                     ("mulu" "*" ) ("divu" "/" )
                     )))
           (if (and *debug* (stringp line)) (format f "//~A~%" line))
           (if (and
                 (listp line)
                 (equalp "=" (nth 1 line)))
             (let ((pc (car line))
                   (asm (cddr line)))
               (if *debug* (format f "//~8X : ~{~x ~}~%" pc asm))
               (format f "'h~8,'0x : begin " pc)
               (do*((k1 (+ k 1) (+ k1 1))
                    (line1 (nth k1 *asm*) (nth k1 *asm*)))
                 ((or
                    (= k1 (length *asm*))
                    (and line1 (listp line1) (equalp "=" (nth 1 line1))))
                  (if line1
                  (let*((pc1 (car line1))
                        (pci (- pc1 pc)))
                    ;(format t "~S -> ~%~S~%" line line1)
                    ;(format t "~x - ~x = ~x~%" pc1 pc pci)
                    (if (/= pci 
                            (cond
                              ((= *msb* 31) 4)
                              ((= *msb* 63) 8)
                              ((= *msb* 15) 2)
                              (t 1)))
                      (format f "pc <= pc + ~D; " pci))
                    ))))
               (cond
                 ((member (car asm) '("mv" "li" "move") :test #'equalp)
                  (let ((r0 (nth 1 asm))
                        (r1 (nth 2 asm)))
                    ;(format t "~A: ~S~%" pc asm)
                    (format f "~A <= ~A; " r0 r1)
                    ))
                 ((member (car asm) '("mtlo" "mthi") :test #'equalp)
                  (let ((r1 (nth 1 asm))
                        (r0 (string-upcase(string-trim "mf" (car asm)))))
                    (format f "~A <= ~A; " r0 r1)
                    ))
                 ((member (car asm) '("mflo" "mfhi") :test #'equalp)
                  (let ((r0 (nth 1 asm))
                        (r1 (string-upcase(string-trim "mf" (car asm)))))
                    (format f "~A <= ~A; " r0 r1)
                    ))
                 ((assoc (car asm) op2 :test #'equalp)
                  (let ((r0 (nth 1 asm))
                        (i1 (nth 2 asm))
                        (p (cadr(assoc (car asm) op2 :test #'equalp))))
                    (format f "~A <= ~A & ~A; " r0 p i1)
                    ))
                 ((assoc (car asm) op1 :test #'equalp)
                  (let ((r0 (nth 1 asm))
                        (i1 (nth 2 asm))
                        (p (cadr(assoc (car asm) op1 :test #'equalp))))
                    (format f "~A <= ~A~A; " r0 p i1)
                    ))
                 ((assoc (car asm) op :test #'equalp)
                  (let ((r0 (nth 1 asm))
                        (r1 (nth 2 asm))
                        (i1 (nth 3 asm))
                        (p (cadr(assoc (car asm) op :test #'equalp))))
                    (cond
                      ((member (subseq (car asm) 0 2) '("sl" "sr") :test #'equalp)
                       (format f "~A <= $unsigned(~A) ~A ~A; " r0 r1 p i1))
                      ((char= #\u (char (reverse (car asm)) 0))
                       (format f "~A <= $unsigned(~A) ~A $unsigned(~A); " r0 r1 p i1))
                      (t (format f "~A <= $signed(~A) ~A $signed(~A); " r0 r1 p i1)))
                    ))
                 ((member (car asm) '("mulh") :test #'equalp)
                  (let*((r0 (nth 1 asm))
                        (r1 (nth 2 asm))
                        (i1 (nth 3 asm)))
                    (if (numberp i1) (setf i1 (with-output-to-string (s1) (format s1 "~d" i1))))
                    (format f "~A <= ($signed(~A) * $signed(~A))>>32; " r0 r1 i1)
                    ))
                 ((member (car asm) '("mulhu") :test #'equalp)
                  (let*((r0 (nth 1 asm))
                        (r1 (nth 2 asm))
                        (i1 (nth 3 asm)))
                    (if (numberp i1) (setf i1 (with-output-to-string (s1) (format s1 "~d" i1))))
                    (format f "~A <= ($unsigned(~A) * $unsigned(~A))>>32; " r0 r1 i1)
                    ))
                 ((member (car asm) '("mulhsu") :test #'equalp)
                  (let*((r0 (nth 1 asm))
                        (r1 (nth 2 asm))
                        (i1 (nth 3 asm)))
                    (if (numberp i1) (setf i1 (with-output-to-string (s1) (format s1 "~d" i1))))
                    (format f "~A <= ($signed(~A) * $unsigned(~A))>>32; " r0 r1 i1)
                    ))
                 ((member (car asm) '("sra" "srai" "srav") :test #'equalp)
                  (let*((r0 (nth 1 asm))
                        (r1 (nth 2 asm))
                        (i1 (nth 3 asm)))
                    (if (numberp i1) (setf i1 (with-output-to-string (s1) (format s1 "~d" i1))))
                    ;(format f "~A <= ~A; " r0 (concatenate 'string r1"[31] ? ~((~"r1")>>"i1") : "r1">>"i1))
                    (format f "~A <= $signed(~A) >>> ~A; " r0 r1 i1)
                    ))
                 ((member (car asm) '("seq" "sequ" "seqi" "seqiu" "seqz" "sequz") :test #'equalp)
                  (let*((r0 (nth 1 asm))
                        (r1 (nth 2 asm))
                        (i1 (if (member (car asm) '("seqz" "sequz") :test #'equalp) 0 (nth 3 asm))))
                    (if (numberp i1) (setf i1 (with-output-to-string (s1) (format s1 "~d" i1))))
                    (format f "~A <= (~A == ~A) ? 1 : 0; " r0 r1 i1)
                    ))
                 ((member (car asm) '("sne" "sneu" "snei" "sneiu" "snez" "sneuz") :test #'equalp)
                  (let*((r0 (nth 1 asm))
                        (r1 (nth 2 asm))
                        (i1 (if (member (car asm) '("snez" "sneuz") :test #'equalp) 0 (nth 3 asm))))
                    (if (numberp i1) (setf i1 (with-output-to-string (s1) (format s1 "~d" i1))))
                    (format f "~A <= (~A != ~A) ? 1 : 0; " r0 r1 i1)
                    ))
                 ((member (car asm) '("slt" "sltu" "slti" "sltiu" "sltz" "sltuz") :test #'equalp)
                  (let*((r0 (nth 1 asm))
                        (r1 (nth 2 asm))
                        (i1 (if (member (car asm) '("sltz" "sltuz") :test #'equalp) 0 (nth 3 asm))))
                    (if (numberp i1) (setf i1 (with-output-to-string (s1) (format s1 "~d" i1))))
                    (format f "~A <= (~A < ~A) ? 1 : 0; " r0 r1 i1)
                    ))
                 ((member (car asm) '("sgt" "sgtu" "sgti" "sgtiu" "sgtz" "sgtuz") :test #'equalp)
                  (let*((r0 (nth 1 asm))
                        (r1 (nth 2 asm))
                        (i1 (if (member (car asm) '("sgtz" "sgtuz") :test #'equalp) 0 (nth 3 asm))))
                    (if (numberp i1) (setf i1 (with-output-to-string (s1) (format s1 "~d" i1))))
                    (format f "~A <= (~A > ~A) ? 1 : 0; " r0 r1 i1)
                    ))
                 ((equalp (car asm) "lui")
                  (let ((r0 (nth 1 asm))
                        (i1 (nth 2 asm)))
                    (format f "~A <= ~A << 12; " r0 i1)
                    ))
                 ((equalp (car asm) "jal")
                  (let ((r0 (nth 1 asm))
                        (i1 (nth 2 asm)))
                    ;(format f "~A <= ~A + ~A; " *pc* *pc* i1)
                    (format f "~A <= ~A; " *pc* i1)
                    (format f "~A <= ~A + 4; " r0 *pc*)
                    ))
                 ((member (car asm) '("j" "jr" "b") :test #'equalp)
                  (let ((r0 (nth 1 asm)))
                    (format f "~A <= ~A; " *pc* r0)
                    ))
                 ((member (car asm) '("jalr") :test #'equalp)
                  (let ((r0 (nth 1 asm))
                        (r1 (nth 2 asm)))
                    (setf r1 (string-trim '(#\( #\)) r1))
                    (format f "~A <= $signed(~A) + $signed(~A); " *pc* r0 r1)
                    (format f "~A <= ~A + 4; " r1 *pc*)
                    ))
                 ((member (car asm) '("ret") :test #'equalp) (format f "~A <= ra; " *pc*))
                 ((assoc (car asm) br1 :test #'equalp)
                  (let ((r0 (nth 1 asm))
                        (i1 (nth 2 asm))
                        (o (cadr (assoc (car asm) br1 :test #'equalp))))
                    (format f "if($signed(~A)~A) ~A <= ~A; " r0 o *pc* i1)
                    ))
                 ((assoc (car asm) br2 :test #'equalp)
                  (let ((r0 (nth 1 asm))
                        (r1 (nth 2 asm))
                        (i1 (nth 3 asm))
                        (o (cadr (assoc (car asm) br2 :test #'equalp))))
                    (format f "if($signed(~A) ~A $signed(~A)) ~A <= ~A; " r0 o r1 *pc* i1)
                    ))
                 ((assoc (car asm) br3 :test #'equalp)
                  (let ((r0 (nth 1 asm))
                        (r1 (nth 2 asm))
                        (i1 (nth 3 asm))
                        (o (cadr (assoc (car asm) br3 :test #'equalp))))
                    (format f "if(~A ~A ~A) ~A <= ~A; " r0 o r1 *pc* i1)
                    ))
                 ((equalp (car asm) "auipc")
                  (let ((r0 (nth 1 asm))
                        (i1 (nth 2 asm)))
                    (format f "~A <= ~A + (~A << 12); " r0 *pc* i1)
                    ))
                 ((member (car asm) '("lw" "lwu") :test #'equalp)
                  (let ((rd (nth 1 asm))
                        (of (nth 2 asm))
                        (r1 (nth 3 asm)))
                    (setf r1 (string-trim '(#\( #\)) r1))
                    (format f "if(!~A) begin ~A = ~A + ~A; ~A <= 1; ~A <= 0; ~A <= 2; ~A <= ~A; end " *valid* *addr* of r1 *valid* *write* *size* *pc* *pc*)
                    (format f "else if(~A && !~A) begin ~A <= ~A; end " *valid* *ready* *pc* *pc*)
                    (format f "else if(~A && ~A) begin ~A <= 0; end " *valid* *ready* *valid*)
                    (format f "if(~A) ~A <= ~A_w; " *ready* rd *rdata*)
                    ))
                 ((member (car asm) '("sw" "swu") :test #'equalp)
                  (let ((rd (nth 1 asm))
                        (of (nth 2 asm))
                        (r1 (nth 3 asm)))
                    (setf r1 (string-trim '(#\( #\)) r1))
                    (format f "if(!~A) begin ~A = $signed(~A) + $signed(~A); ~A <= 1; ~A <= 1; ~A <= 2; ~A <= ~A; ~A <= ~A; end " *valid* *addr* of r1 *valid* *write* *size* *wdata* rd *pc* *pc*)
                    (format f "else if(~A && !~A) begin ~A <= ~A; end " *valid* *ready* *pc* *pc*)
                    (format f "else if(~A && ~A) begin ~A <= 0; end " *valid* *ready* *valid*)
                    ))
                 ((member (car asm) '("lh" "lhu") :test #'equalp)
                  (let ((rd (nth 1 asm))
                        (of (nth 2 asm))
                        (r1 (nth 3 asm)))
                    (setf r1 (string-trim '(#\( #\)) r1))
                    (format f "if(!~A) begin ~A = $signed(~A) + $signed(~A); ~A <= 1; ~A <= 0; ~A <= 1; ~A <= ~A; end " *valid* *addr* of r1 *valid* *write* *size* *pc* *pc*)
                    (format f "else if(~A && !~A) begin ~A <= ~A; end " *valid* *ready* *pc* *pc*)
                    (format f "else if(~A && ~A) begin ~A <= 0; end " *valid* *ready* *valid*)
                    (if (equalp (car asm) "lhu")
                      (format f "if(~A) ~A <= {{16{1'b0}},~A_h}; " *ready* rd *rdata*)
                      (format f "if(~A) ~A <= {{16{~A_h[15]}},~A_h}; " *ready* rd *rdata* *rdata*)
                      )
                    ))
                 ((member (car asm) '("sh" "shu") :test #'equalp)
                  (let ((rd (nth 1 asm))
                        (of (nth 2 asm))
                        (r1 (nth 3 asm)))
                    (setf r1 (string-trim '(#\( #\)) r1))
                    ;(format f "if(!~A) begin ~A = $signed(~A) + $signed(~A); ~A <= 1; ~A <= 1; ~A <= 1; ~A <= ~A[15:0]<<(8*~A[1:0]); ~A <= ~A; end " *valid* *addr* of r1 *valid* *write* *size* *wdata* rd *addr* *pc* *pc*)
                    (format f "if(!~A) begin ~A = $signed(~A) + $signed(~A); ~A <= 1; ~A <= 1; ~A <= 1; ~A <= ~A[15:0]; ~A <= ~A; end " *valid* *addr* of r1 *valid* *write* *size* *wdata* rd *pc* *pc*)
                    (format f "else if(~A && !~A) begin ~A <= ~A; end " *valid* *ready* *pc* *pc*)
                    (format f "else if(~A && ~A) begin ~A <= 0; end " *valid* *ready* *valid*)
                    ))
                 ((member (car asm) '("lb" "lbu") :test #'equalp)
                  (let ((rd (nth 1 asm))
                        (of (nth 2 asm))
                        (r1 (nth 3 asm)))
                    (setf r1 (string-trim '(#\( #\)) r1))
                    (format f "if(!~A) begin ~A = $signed(~A) + $signed(~A); ~A <= 1; ~A <= 0; ~A <= 0; ~A <= ~A; end " *valid* *addr* of r1 *valid* *write* *size* *pc* *pc*)
                    (format f "else if(~A && !~A) begin ~A <= ~A; end " *valid* *ready* *pc* *pc*)
                    (format f "else if(~A && ~A) begin ~A <= 0; end " *valid* *ready* *valid*)
                    (if (equalp (car asm) "lbu")
                      (format f "if(~A) ~A <= {{24{1'b0}},~A_b}; " *ready* rd *rdata*)
                      (format f "if(~A) ~A <= {{24{~A_h[7]}},~A_b}; " *ready* rd *rdata* *rdata*)
                      )
                    ))
                 ((member (car asm) '("sb" "sbu") :test #'equalp)
                  (let ((rd (nth 1 asm))
                        (of (nth 2 asm))
                        (r1 (nth 3 asm)))
                    (setf r1 (string-trim '(#\( #\)) r1))
                    ;(format f "if(!~A) begin ~A = $signed(~A) + $signed(~A); ~A <= 1; ~A <= 1; ~A <= 0; ~A <= ~A[7:0]<<(8*~A[1:0]); ~A <= ~A; end " *valid* *addr* of r1 *valid* *write* *size* *wdata* rd *addr* *pc* *pc*)
                    (format f "if(!~A) begin ~A = $signed(~A) + $signed(~A); ~A <= 1; ~A <= 1; ~A <= 0; ~A <= ~A[7:0]; ~A <= ~A; end " *valid* *addr* of r1 *valid* *write* *size* *wdata* rd *pc* *pc*)
                    (format f "else if(~A && !~A) begin ~A <= ~A; end " *valid* *ready* *pc* *pc*)
                    (format f "else if(~A && ~A) begin ~A <= 0; end " *valid* *ready* *valid*)
                    ))
                 ((member (car asm) '("nop") :test #'equalp))
                 (t (let ()
                      (push (list 'unmapped line) *log*)
                      )))
               (format f "end~%")
               ))
           (if (and
                 (listp line)
                 (equalp "=" (nth 2 line)))
             (let ((pc (car line))
                   (label (cadr line)))
               (if *debug* (format f "//  ~8X : ~X ~%" pc label))
               ))
           ))
       (format f "        default : ~A <= ~A;~%" *pc* *pc*)
       (format f "      endcase~%")
       (format f "    end~%")
       (format f "  end~%")
       (format f "end~%")
       ))
    )
  (if *module*
    (let ()
      (format f "endmodule~%")
      )))

(let ((argv sb-ext:*posix-argv*))
  (dotimes (argc (length argv))
    (cond
      ((and
         (equalp (nth argc argv) "-s")
         (nth (1+ argc) argv)
         (probe-file (nth (1+ argc) argv)))
       (let ()
         (with-open-file (s (nth (1+ argc) argv) :direction :input) 
           (read-asm s))
         ;(format t "~{~s~%~}" *asm*)
         ))
      ((equalp (nth argc argv) "-g") (setf *debug* t))
      ((and
         (equalp (nth argc argv) "-rstb")
         (nth (1+ argc) argv))
       (let ()
         (setf *rstb* (nth (1+ argc) argv))
         ))
      ((and
         (equalp (nth argc argv) "-clk")
         (nth (1+ argc) argv))
       (let ()
         (setf *clk* (nth (1+ argc) argv))
         ))
      ((and
         (equalp (nth argc argv) "-pc")
         (nth (1+ argc) argv))
       (let ()
         (setf *pc* (nth (1+ argc) argv))
         ))
      ((and
         (equalp (nth argc argv) "-setb")
         (nth (1+ argc) argv))
       (let ()
         (setf *setb* (nth (1+ argc) argv))
         ))
      ((and
         (equalp (nth argc argv) "-idle")
         (nth (1+ argc) argv))
       (let ()
         (setf *idle* (nth (1+ argc) argv))
         ))
      ((and
         (equalp (nth argc argv) "-top")
         (nth (1+ argc) argv))
       (let ()
         (setf *module* (nth (1+ argc) argv))
         ))
      ((and
         (equalp (nth argc argv) "-t")
         (nth (1+ argc) argv))
       (let ()
         (setf *cpu* (nth (1+ argc) argv))
         ))
      ((and
         (equalp (nth argc argv) "-o")
         (nth (1+ argc) argv))
       (let ()
         (setf *hdl* (nth (1+ argc) argv))
         ))
      ))
  (if (or
        (not(cdr argv))
        (and
          (cdr argv)
          (member "-h" (cdr argv) :test #'equalp))
        )
    (let ()
      (format t "-h     help                       ~%")
      (format t "-g     debug                      ~%")
      (format t "-s     [asm file]                 ~%")
      (format t "-clk   [clock]                    ~%")
      (format t "-rsrb  [reset not]                ~%")
      (format t "-pc    [pc name]                  ~%")
      (format t "-setb  [enable name]              ~%")
      (format t "-idle  [idle name]                ~%")
      (format t "-top   [module name]              ~%")
      (format t "-t     [target: rv32i, rv32e ]    ~%")
      (format t "-o     [output verilog hdl file ] ~%")
      )
    (let ()
      (if *hdl*
        (with-open-file (s *hdl* :direction :output :if-does-not-exist :create :if-exists :supersede) (cpu s))
        (cpu t))
      (format t "~{~A~%~}" (reverse *log*))
      )))
